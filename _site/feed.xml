<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2019-09-21T19:56:57+08:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Abear</title><subtitle>每一天都是一个新的开始，今天与明天最大的不同，今天我还活着，明天却毫无感觉。所以时刻注重今天的美好时光，热爱生活，热爱创造。</subtitle><author><name>abearxiong</name></author><entry><title type="html">关于sublime Text 3增加功能插件开发</title><link href="http://0.0.0.0:4000/sublime/text/3/2019/09/%E5%85%B3%E4%BA%8Esublime-Text-3%E5%A2%9E%E5%8A%A0%E5%8A%9F%E8%83%BD%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html" rel="alternate" type="text/html" title="关于sublime Text 3增加功能插件开发" /><published>2019-09-16T23:18:49+08:00</published><updated>2019-09-16T23:18:49+08:00</updated><id>http://0.0.0.0:4000/sublime/text/3/2019/09/%E5%85%B3%E4%BA%8Esublime-Text-3%E5%A2%9E%E5%8A%A0%E5%8A%9F%E8%83%BD%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91</id><content type="html" xml:base="http://0.0.0.0:4000/sublime/text/3/2019/09/%E5%85%B3%E4%BA%8Esublime-Text-3%E5%A2%9E%E5%8A%A0%E5%8A%9F%E8%83%BD%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html">&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import sublime
import sublime_plugin
import threading
import time

class ExampleCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        self.view.insert(edit, 0, &quot;Hello, World!&quot;)

i=0

class timer(threading.Thread): #The timer class is derived from the class threading.Thread  
    def __init__(self, num, interval):
        threading.Thread.__init__(self)
        self.thread_num = num
        self.interval = interval
        self.thread_stop = False 
    def run(self): #Overwrite run() method, put what you want the thread do here
        global i
        while not self.thread_stop:
            sublime.set_timeout(write_time,1)
            i+=1  
            time.sleep(self.interval)          
    def pause(self):        
        self.thread_stop = True
    
    def zero(self):
        global i
        i=0    



thread1 = timer(1, 1)
class gtimerCommand(sublime_plugin.TextCommand):    
    def run(self, edit):
        global thread1
        thread=timer(1,1) 
        if thread1.isAlive():
            live=True
        else:                               
            thread.start()
            thread1=thread

class gtimerpauseCommand(sublime_plugin.TextCommand):    
    def run(self, edit):         
        global thread1
        thread1.pause()

class gtimerzeroCommand(sublime_plugin.TextCommand):    
    def run(self, edit):
        global thread1         
        thread1.zero()
        
   
def write_time():
    sublime.status_message(time_manage(i))

def time_manage(time_number):
    time_str=' time: '+str(int(time_number/60))+'min '+str(time_number%60)+'s'
    return time_str

# ---
# layout: post
# title: 关于sublime Text 3增加功能插件开发 
# date: 2019-09-16 23:18:49 +0800 
# categories: Sublime Text 3 
# tags: [&quot;plugin&quot;, &quot;插件&quot;, &quot;Sublime&quot;]
# notebook: Sublime Text 3
# disqus: false
# gitalk: true
# description: 对内容的描述
# ---

class ToltCommand(sublime_plugin.TextCommand):
    '''
    格式化&amp;lt;&amp;gt;标签进行转义
    '''
    def run(self, edit):
        for region in reversed(self.view.find_all(&quot;&amp;lt;&quot;)): 
            if not region.empty(): 
                self.view.replace(edit, region, &quot;&amp;amp;lt;&quot;) 
        for region in reversed(self.view.find_all(&quot;&amp;gt;&quot;)):
            if not region.empty():
                self.view.replace(edit, region, &quot;&amp;amp;gt;&quot;)

class NltCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        for region in reversed(self.view.find_all(&quot;&amp;amp;lt;&quot;)):
            if not region.empty():
                self.view.replace(edit, region, &quot;&amp;lt;&quot;)        
        for region in reversed(self.view.find_all(&quot;&amp;amp;gt;&quot;)):
            if not region.empty():
                self.view.replace(edit, region, &quot;&amp;gt;&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上是源码，搜索资料研究的关于状态栏的运行时间，关于转义标签的问题。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.sublimetext.com/docs/3/api_reference.html&quot;&gt;api文档 english&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://feliving.github.io/Sublime-Text-3-Documentation/api_reference.html&quot;&gt;api document chinese&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sublime-text.readthedocs.io/en/latest/intro.html&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;命令面板&quot;&gt;命令面板&lt;/h3&gt;

&lt;p&gt;是一个绑定到键盘 Ctrl+Shift+P 的交互列表，其目的在意执行命令。命令面板 与命令文件相互联系。通常，命令不保证产生一个按键绑定，可以在 .sublime-commands 中作为一些很好的候选。&lt;/p&gt;

&lt;p&gt;Defult.sublime-commonds&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
    { &quot;caption&quot;: &quot;Time Start&quot;, &quot;command&quot;: &quot;gtimer&quot; },
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>abearxiong</name></author><category term="plugin" /><category term="插件" /><category term="Sublime" /><summary type="html">import sublime import sublime_plugin import threading import time class ExampleCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.insert(edit, 0, &quot;Hello, World!&quot;) i=0 class timer(threading.Thread): #The timer class is derived from the class threading.Thread def __init__(self, num, interval): threading.Thread.__init__(self) self.thread_num = num self.interval = interval self.thread_stop = False def run(self): #Overwrite run() method, put what you want the thread do here global i while not self.thread_stop: sublime.set_timeout(write_time,1) i+=1 time.sleep(self.interval) def pause(self): self.thread_stop = True def zero(self): global i i=0 thread1 = timer(1, 1) class gtimerCommand(sublime_plugin.TextCommand): def run(self, edit): global thread1 thread=timer(1,1) if thread1.isAlive(): live=True else: thread.start() thread1=thread class gtimerpauseCommand(sublime_plugin.TextCommand): def run(self, edit): global thread1 thread1.pause() class gtimerzeroCommand(sublime_plugin.TextCommand): def run(self, edit): global thread1 thread1.zero() def write_time(): sublime.status_message(time_manage(i)) def time_manage(time_number): time_str=' time: '+str(int(time_number/60))+'min '+str(time_number%60)+'s' return time_str # --- # layout: post # title: 关于sublime Text 3增加功能插件开发 # date: 2019-09-16 23:18:49 +0800 # categories: Sublime Text 3 # tags: [&quot;plugin&quot;, &quot;插件&quot;, &quot;Sublime&quot;] # notebook: Sublime Text 3 # disqus: false # gitalk: true # description: 对内容的描述 # --- class ToltCommand(sublime_plugin.TextCommand): ''' 格式化&amp;lt;&amp;gt;标签进行转义 ''' def run(self, edit): for region in reversed(self.view.find_all(&quot;&amp;lt;&quot;)): if not region.empty(): self.view.replace(edit, region, &quot;&amp;amp;lt;&quot;) for region in reversed(self.view.find_all(&quot;&amp;gt;&quot;)): if not region.empty(): self.view.replace(edit, region, &quot;&amp;amp;gt;&quot;) class NltCommand(sublime_plugin.TextCommand): def run(self, edit): for region in reversed(self.view.find_all(&quot;&amp;amp;lt;&quot;)): if not region.empty(): self.view.replace(edit, region, &quot;&amp;lt;&quot;) for region in reversed(self.view.find_all(&quot;&amp;amp;gt;&quot;)): if not region.empty(): self.view.replace(edit, region, &quot;&amp;gt;&quot;) 以上是源码，搜索资料研究的关于状态栏的运行时间，关于转义标签的问题。 api文档 english api document chinese 文档 命令面板 是一个绑定到键盘 Ctrl+Shift+P 的交互列表，其目的在意执行命令。命令面板 与命令文件相互联系。通常，命令不保证产生一个按键绑定，可以在 .sublime-commands 中作为一些很好的候选。 Defult.sublime-commonds [ { &quot;caption&quot;: &quot;Time Start&quot;, &quot;command&quot;: &quot;gtimer&quot; }, ]</summary></entry><entry><title type="html">关于tarojs的微信小程序的了解和学习?</title><link href="http://0.0.0.0:4000/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/2019/09/%E5%85%B3%E4%BA%8Etarojs%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%92%8C%E5%AD%A6%E4%B9%A0.html" rel="alternate" type="text/html" title="关于tarojs的微信小程序的了解和学习?" /><published>2019-09-16T21:02:09+08:00</published><updated>2019-09-16T21:02:09+08:00</updated><id>http://0.0.0.0:4000/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/2019/09/%E5%85%B3%E4%BA%8Etarojs%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%92%8C%E5%AD%A6%E4%B9%A0</id><content type="html" xml:base="http://0.0.0.0:4000/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/2019/09/%E5%85%B3%E4%BA%8Etarojs%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%92%8C%E5%AD%A6%E4%B9%A0.html">&lt;h2 id=&quot;主要记录安装方式和一些坑&quot;&gt;主要记录安装方式和一些坑&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;我是先在原生微信小程序做了一个页面，然后又从taro做了一个页面，我做整理的时候发现，&lt;code class=&quot;highlighter-rouge&quot;&gt;taro convert&lt;/code&gt;可以直接转换&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;安装taro的过程&quot;&gt;安装taro的过程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;全局安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm i -g @tarojs/cli&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;taro初始化应用 &lt;code class=&quot;highlighter-rouge&quot;&gt;taro init myApp &lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;安装依赖 &lt;code class=&quot;highlighter-rouge&quot;&gt;yarn&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;yarn dev:weapp&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;运行其他雷士的小程序就是改dev，看package.json&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其他的开发过程，类似于普通的React开发&lt;/p&gt;

&lt;h3 id=&quot;坑&quot;&gt;坑&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;config:Config={navigationBarTitleText: '首页'}&lt;/code&gt;配置标题&lt;/li&gt;
  &lt;li&gt;在app.tsx中的config配置页面和window的模块，navigationStyle配置custom隐藏默认的微信小程序的样式结构。然后全自定义微信小程序的标题页面。&lt;/li&gt;
  &lt;li&gt;构置SCSS的样式，可以直接转css到SCSS，网上有网页工具。&lt;/li&gt;
  &lt;li&gt;微信小程序预览模式，要关闭ES6转ES5，关闭上传代码自动补全，关闭代码压缩上传。&lt;/li&gt;
  &lt;li&gt;关于静态资源，感觉需要放在pages的同级目录下面，css全局样式也是。&lt;/li&gt;
  &lt;li&gt;不能使用id选择器。关于外部样式的一些问题&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;在了解到taro后&quot;&gt;在了解到taro后&lt;/h3&gt;

&lt;p&gt;我感觉到开发小程序，在同步多个不同的小程序，是可以通过这个来实现应有的需求的。&lt;/p&gt;</content><author><name>abearxiong</name></author><category term="taro" /><category term="React" /><category term="tarojs" /><category term="微信小程序" /><summary type="html">主要记录安装方式和一些坑 我是先在原生微信小程序做了一个页面，然后又从taro做了一个页面，我做整理的时候发现，taro convert可以直接转换 安装taro的过程 全局安装 npm i -g @tarojs/cli taro初始化应用 taro init myApp 安装依赖 yarn 运行 yarn dev:weapp 运行其他雷士的小程序就是改dev，看package.json 其他的开发过程，类似于普通的React开发 坑 在config:Config={navigationBarTitleText: '首页'}配置标题 在app.tsx中的config配置页面和window的模块，navigationStyle配置custom隐藏默认的微信小程序的样式结构。然后全自定义微信小程序的标题页面。 构置SCSS的样式，可以直接转css到SCSS，网上有网页工具。 微信小程序预览模式，要关闭ES6转ES5，关闭上传代码自动补全，关闭代码压缩上传。 关于静态资源，感觉需要放在pages的同级目录下面，css全局样式也是。 不能使用id选择器。关于外部样式的一些问题 在了解到taro后 我感觉到开发小程序，在同步多个不同的小程序，是可以通过这个来实现应有的需求的。</summary></entry><entry><title type="html">Electron C# dll hook获取活动窗口的进程和路径</title><link href="http://0.0.0.0:4000/eelectron/2019/09/Electron+C-dll-hook%E8%8E%B7%E5%8F%96%E6%B4%BB%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%B7%AF%E5%BE%84.html" rel="alternate" type="text/html" title="Electron C# dll hook获取活动窗口的进程和路径" /><published>2019-09-15T15:57:52+08:00</published><updated>2019-09-15T15:57:52+08:00</updated><id>http://0.0.0.0:4000/eelectron/2019/09/Electron+C#-dll-hook%E8%8E%B7%E5%8F%96%E6%B4%BB%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%B7%AF%E5%BE%84</id><content type="html" xml:base="http://0.0.0.0:4000/eelectron/2019/09/Electron+C-dll-hook%E8%8E%B7%E5%8F%96%E6%B4%BB%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%B7%AF%E5%BE%84.html">&lt;p&gt;在实现这个要求前，需要有node-gyp，node-gyp需要有python2.7,visual studio2015的什么动态链接库。为了简便方法的安装，我安装的的方法是直接安装windows-build-tools的包。&lt;/p&gt;

&lt;h2 id=&quot;windows的环境&quot;&gt;Windows的环境&lt;/h2&gt;

&lt;h3 id=&quot;1-安装gyp&quot;&gt;1. 安装gyp&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-npm&quot;&gt;npm i -g node-gyp
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2-安装扩展包&quot;&gt;2. 安装扩展包&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install --global --production windows-build-tools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-配置python路径&quot;&gt;3. 配置python路径&lt;/h3&gt;

&lt;p&gt;路径的位置是在系统用户的文件夹下的.windows-build-tools里面。c:/user/用户/.windows-build-tools&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-node&quot;&gt;node-gyp python --python /path/to/python27
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;安装electron&quot;&gt;安装Electron&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i -g electron@latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1-建立工程&quot;&gt;1. 建立工程&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-npm&quot;&gt;mkdir electron-demo
npm init
npm i electron
npm i electron-edge-js
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2-初始化indexhtml和indexjs&quot;&gt;2. 初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;index.html&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
   测试&lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const { app,BrowserWindow } = require('electron')
var edge = require('electron-edge-js')
// let createWindow =  () =&amp;gt;{
//     let win = new BrowserWindow ({
//         nodeIntegration: true
//     })
//     win.loadFile(&quot;index.html&quot;)
//     console.log(&quot;启动&quot;,Number.parseInt('256')) //发现的程序内的hook
//     win.hookWindowMessage(Number.parseInt('256'),( wParm, lParm)=&amp;gt;{
//         let eventName = null
//         console.log(wParm,&quot;参数&quot;)
//     }) //Number.parseInt('0xD')
//     let isHook = win.isWindowMessageHooked(Number.parseInt('256'))
//     console.log(isHook)
//     let fileName = win.getRepresentedFilename()
// }

let createWindow = () =&amp;gt; {
    let win = new BrowserWindow({
        nodeIntegration: true
    })
    win.loadFile(&quot;index.html&quot;) // 加载HTML
    console.log(&quot;启动&quot;)
    let HelloDll = edge.func({
        assemblyFile: 'winkey.dll',
        typeName: 'winkey.GetActivity',
        methodName: 'HelloDll'
    }) // 测试DLL
    let HookStart = edge.func({
        assemblyFile: 'winkey.dll',
        typeName: 'winkey.GetActivity',
        methodName: 'HookStart'
    }) // 开始进程
    let GetData = edge.func({
        assemblyFile: 'winkey.dll',
        typeName: 'winkey.GetActivity',
        methodName: 'GetData'
    }) // 获取进程的变量
    HelloDll(1, 2, function (err, result) {
        if (err) {
            console.log(&quot;err&quot;, err)
        } else {
            console.log(&quot;result&quot;, result)
        }
    })
    HookStart(1,function(err,result){
        if (err) {
            console.log(&quot;err&quot;, err)
        } else {
            console.log(&quot;HookStart result&quot;, result)
        }
    })
    setInterval(() =&amp;gt; {
       GetData(1,function(err,result){
        if (err) {
            console.log(&quot;err&quot;, err)
        } else {
            console.log(&quot;result&quot;, result)
        }
       })
    }, 2000);   // 每隔两秒进行打印所激活窗口的一些值，进程名字，进程ID，进程的路径
}
app.on('ready', createWindow)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-c-创建dll建立hook窗口的程序&quot;&gt;3. C# 创建DLL，建立Hook窗口的程序&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;使用Visual Studio创建工程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新建，选择类库（.Net FrameWork),自己创建自己的工程，我创建的是winkey,修改文件名类的名字GetActivity,和Electron的对应。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows;


namespace winkey
{
    public class GetActivity
    {
        private System.Threading.Timer threadTimer;
        private Process myProcess;
        volatile public static String Data =&quot;内容&quot;;
        public async Task&amp;lt;object&amp;gt; HelloDll(object input)
        {
            Console.WriteLine(&quot;输入HelloDLL&quot;);
            Console.WriteLine(input);
            return &quot;helloDll&quot;;
        }
        public async Task&amp;lt;object&amp;gt; GetData(object input)
        {
            Console.WriteLine(&quot;Data---&quot;+ GetActivity.Data);
            return GetActivity.Data;
        }
        public async Task&amp;lt;object&amp;gt; HookStart(object input)
        {
            threadTimer = new System.Threading.Timer(new System.Threading.TimerCallback(GetValue), null, 0, 2000);
            return &quot;start&quot;;
        }
        public async Task&amp;lt;object&amp;gt; HookEnd(object input)
        {
            threadTimer.Dispose();
            return &quot;0&quot;;
        }
        [DllImport(&quot;User32.dll&quot;)]
        public static extern IntPtr GetForegroundWindow(); //获取活动窗口句柄

        [DllImport(&quot;User32.dll&quot;)]
        public static extern int GetWindowThreadProcessId(IntPtr hwnd, out int ID); //获取线程ID

        /// &amp;lt;summary&amp;gt;
        /// 获取进程的内容
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;state&quot;&amp;gt;&amp;lt;/param&amp;gt;
        private void GetValue(Object state)
        {
            //Thread.Sleep(3000);    //睡眠3s，用来选择活动窗口
            IntPtr hWnd = GetForegroundWindow();    //获取活动窗口句柄
            int calcID = 0;    //进程ID
            int calcTD = 0;    //线程ID
            calcTD = GetWindowThreadProcessId(hWnd, out calcID);
            myProcess = Process.GetProcessById(calcID);
            String getInfo;
            try
            {
                getInfo = &quot;进程名：&quot; + myProcess.ProcessName + &quot;\n&quot; + &quot;进程ID：&quot; + calcID + &quot;\n&quot; + &quot;程序路径：&quot; + myProcess.MainModule.FileName;
                //Console.WriteLine(getInfo);  //在MessageBox中显示获取的信息
                GetActivity.Data = getInfo;
            }
            catch
            {
                getInfo = &quot;程序不能读取路径&quot; + &quot;进程名：&quot; + myProcess.ProcessName + &quot;\n&quot; + &quot;进程ID：&quot; + calcID + &quot;\n&quot;; // 不能获取类似于cmd的路径，所以就try catch
                //Console.WriteLine(getInfo);
                GetActivity.Data = getInfo;
            }

        }
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;生成DLL文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在自己的bin/debug里面&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;复制到Electron的根目录，根据自己Electron读取的路径进行自定义&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在Electron的路径运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;electron . &lt;/code&gt; 因为安装了全局的electron，所以直接运行就好了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;执行的结果如图 electron-hook.gif&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/xiongxiao/image/upload/v1568537455/github/images/electron-hook.gif&quot; alt=&quot;elctron-hook&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/abearxiong/databank/blob/master/Super%20Desktop/electron-hook-demo.zip&quot;&gt;代码地址&lt;/a&gt;&lt;/p&gt;</content><author><name>abearxiong</name></author><category term="Electron" /><category term="Nodejs" /><category term="C#" /><category term="dll" /><summary type="html">在实现这个要求前，需要有node-gyp，node-gyp需要有python2.7,visual studio2015的什么动态链接库。为了简便方法的安装，我安装的的方法是直接安装windows-build-tools的包。 Windows的环境 1. 安装gyp npm i -g node-gyp 2. 安装扩展包 npm install --global --production windows-build-tools 3. 配置python路径 路径的位置是在系统用户的文件夹下的.windows-build-tools里面。c:/user/用户/.windows-build-tools node-gyp python --python /path/to/python27 安装Electron npm i -g electron@latest 1. 建立工程 mkdir electron-demo npm init npm i electron npm i electron-edge-js 2. 初始化index.html和index.js index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; 测试&amp;lt;input type=&quot;text&quot; /&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; index.js const { app,BrowserWindow } = require('electron') var edge = require('electron-edge-js') // let createWindow = () =&amp;gt;{ // let win = new BrowserWindow ({ // nodeIntegration: true // }) // win.loadFile(&quot;index.html&quot;) // console.log(&quot;启动&quot;,Number.parseInt('256')) //发现的程序内的hook // win.hookWindowMessage(Number.parseInt('256'),( wParm, lParm)=&amp;gt;{ // let eventName = null // console.log(wParm,&quot;参数&quot;) // }) //Number.parseInt('0xD') // let isHook = win.isWindowMessageHooked(Number.parseInt('256')) // console.log(isHook) // let fileName = win.getRepresentedFilename() // } let createWindow = () =&amp;gt; { let win = new BrowserWindow({ nodeIntegration: true }) win.loadFile(&quot;index.html&quot;) // 加载HTML console.log(&quot;启动&quot;) let HelloDll = edge.func({ assemblyFile: 'winkey.dll', typeName: 'winkey.GetActivity', methodName: 'HelloDll' }) // 测试DLL let HookStart = edge.func({ assemblyFile: 'winkey.dll', typeName: 'winkey.GetActivity', methodName: 'HookStart' }) // 开始进程 let GetData = edge.func({ assemblyFile: 'winkey.dll', typeName: 'winkey.GetActivity', methodName: 'GetData' }) // 获取进程的变量 HelloDll(1, 2, function (err, result) { if (err) { console.log(&quot;err&quot;, err) } else { console.log(&quot;result&quot;, result) } }) HookStart(1,function(err,result){ if (err) { console.log(&quot;err&quot;, err) } else { console.log(&quot;HookStart result&quot;, result) } }) setInterval(() =&amp;gt; { GetData(1,function(err,result){ if (err) { console.log(&quot;err&quot;, err) } else { console.log(&quot;result&quot;, result) } }) }, 2000); // 每隔两秒进行打印所激活窗口的一些值，进程名字，进程ID，进程的路径 } app.on('ready', createWindow) 3. C# 创建DLL，建立Hook窗口的程序 使用Visual Studio创建工程 新建，选择类库（.Net FrameWork),自己创建自己的工程，我创建的是winkey,修改文件名类的名字GetActivity,和Electron的对应。 using System; using System.Collections.Generic; using System.Diagnostics; using System.Linq; using System.Runtime.InteropServices; using System.Text; using System.Threading.Tasks; using System.Windows; namespace winkey { public class GetActivity { private System.Threading.Timer threadTimer; private Process myProcess; volatile public static String Data =&quot;内容&quot;; public async Task&amp;lt;object&amp;gt; HelloDll(object input) { Console.WriteLine(&quot;输入HelloDLL&quot;); Console.WriteLine(input); return &quot;helloDll&quot;; } public async Task&amp;lt;object&amp;gt; GetData(object input) { Console.WriteLine(&quot;Data---&quot;+ GetActivity.Data); return GetActivity.Data; } public async Task&amp;lt;object&amp;gt; HookStart(object input) { threadTimer = new System.Threading.Timer(new System.Threading.TimerCallback(GetValue), null, 0, 2000); return &quot;start&quot;; } public async Task&amp;lt;object&amp;gt; HookEnd(object input) { threadTimer.Dispose(); return &quot;0&quot;; } [DllImport(&quot;User32.dll&quot;)] public static extern IntPtr GetForegroundWindow(); //获取活动窗口句柄 [DllImport(&quot;User32.dll&quot;)] public static extern int GetWindowThreadProcessId(IntPtr hwnd, out int ID); //获取线程ID /// &amp;lt;summary&amp;gt; /// 获取进程的内容 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;state&quot;&amp;gt;&amp;lt;/param&amp;gt; private void GetValue(Object state) { //Thread.Sleep(3000); //睡眠3s，用来选择活动窗口 IntPtr hWnd = GetForegroundWindow(); //获取活动窗口句柄 int calcID = 0; //进程ID int calcTD = 0; //线程ID calcTD = GetWindowThreadProcessId(hWnd, out calcID); myProcess = Process.GetProcessById(calcID); String getInfo; try { getInfo = &quot;进程名：&quot; + myProcess.ProcessName + &quot;\n&quot; + &quot;进程ID：&quot; + calcID + &quot;\n&quot; + &quot;程序路径：&quot; + myProcess.MainModule.FileName; //Console.WriteLine(getInfo); //在MessageBox中显示获取的信息 GetActivity.Data = getInfo; } catch { getInfo = &quot;程序不能读取路径&quot; + &quot;进程名：&quot; + myProcess.ProcessName + &quot;\n&quot; + &quot;进程ID：&quot; + calcID + &quot;\n&quot;; // 不能获取类似于cmd的路径，所以就try catch //Console.WriteLine(getInfo); GetActivity.Data = getInfo; } } } } 生成DLL文件 在自己的bin/debug里面 复制到Electron的根目录，根据自己Electron读取的路径进行自定义 在Electron的路径运行 electron . 因为安装了全局的electron，所以直接运行就好了。 执行的结果如图 electron-hook.gif 代码地址</summary></entry><entry><title type="html">显卡GTX970驱动安装的问题?</title><link href="http://0.0.0.0:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA/2019/09/%E6%98%BE%E5%8D%A1GTX970%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98.html" rel="alternate" type="text/html" title="显卡GTX970驱动安装的问题?" /><published>2019-09-03T11:17:44+08:00</published><updated>2019-09-03T11:17:44+08:00</updated><id>http://0.0.0.0:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA/2019/09/%E6%98%BE%E5%8D%A1GTX970%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98</id><content type="html" xml:base="http://0.0.0.0:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA/2019/09/%E6%98%BE%E5%8D%A1GTX970%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98.html">&lt;p&gt;在安装系统后，win10会自动带有驱动的，在查看设备管理器的时候，会看到GTX970的设备是显示感叹号的！点开查看显示是设备错误，错误码是43。第一次装的是1903系统。&lt;/p&gt;

&lt;p&gt;使用过鲁大师安装驱动，安装完就黑屏。重启之后，桌面的分辨率是800*800，不能修改。用驱动精灵依旧是这样的问题。&lt;/p&gt;

&lt;p&gt;重装了win10 1809，问题依旧，发现把GTX970的驱动禁用后，重启可以看到分辨率正确。&lt;/p&gt;

&lt;p&gt;一直思考，如果显卡出了问题，为什么，作为一个独显，能够显示，而不是无信号或者黑屏，而只有在安装完驱动，禁用启用才会出现黑屏。&lt;/p&gt;

&lt;p&gt;之后反复装系统，最后装了一次win7，打算测试win是否可行，但是依旧不行，于是用GPU-Z查看显卡，在官网下载的GPU-Z，查看Graphics Card显卡，发现关于Pixel Filrate,关于GPU Clock等等的一些不是为0就是不显示，查看Sensors的菜单，只显示四行，更多的应该有的比如显示器的状态PerfCap Reason等等很多都不显示。所以在大量重装的过程中，到底是显卡，驱动，还是主板出了问题呢？我一直在查询资料。&lt;/p&gt;

&lt;p&gt;偶然查看到了一篇文章&lt;a href=&quot;https://www.bilibili.com/read/cv2353553/&quot;&gt;记一次显卡故障解决日志&lt;/a&gt;,我然后就尝试重装bios，这时，我已经把系统又安装为了win10 1903，win10系统不需要安装鲁大师等等，我发现只要有网络，那么win10可以在设备管理器哪里右键更新驱动程序，自动搜索更新的驱动程序软件进行下载和安装网上的驱动。&lt;/p&gt;

&lt;p&gt;经过BIOS的重新安装，我解决了我两天的系统安装经过。&lt;/p&gt;

&lt;h3 id=&quot;在这里描述一下我是独显能够显示但是驱动安装不上设备管理器显示设备错误43分辨率不对而且不能调整分辨率作为独显能够把驱动禁用正确显示而且用鲁大师可以跑fps为0-3跑分1000gpu-z能识别但是有一些数据不显示这都是我当时的显卡不显示的一些情况&quot;&gt;在这里描述一下，我是独显，能够显示，但是驱动安装不上，设备管理器显示设备错误43，分辨率不对，而且不能调整分辨率。作为独显，能够把驱动禁用，正确显示，而且用鲁大师可以跑，FPS为0-3，跑分1000，GPU-Z能识别，但是有一些数据不显示。这都是我当时的显卡不显示的一些情况。&lt;/h3&gt;

&lt;h3 id=&quot;我刷bios刷的是同一个和自己本身安装的是一样的rom相当于是更新了一下我用nvidia-nvflash刷bios的不能保存bios不能备份我就直接刷了&quot;&gt;我刷bios，刷的是同一个，和自己本身安装的是一样的rom，相当于是更新了一下，我用nvidia nvflash刷bios的，不能保存bios？？？？不能备份，我就直接刷了。&lt;/h3&gt;

&lt;h1 id=&quot;显卡bios重刷&quot;&gt;显卡BIOS重刷&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;找到是在那个网站&lt;a href=&quot;https://www.techpowerup.com&quot;&gt;techpowerup&lt;/a&gt;，无论是amd还是nvdia都是那个网站，下载的东西都在这个网站。刷显卡bios的软件和biso的rom文件。&lt;/li&gt;
  &lt;li&gt;位置1. downloads里面tewaking导航的BIOS flashing刷新bios软件的地方。位置2.首页最上面的导航栏DATABASES中vga bios collection中，查找自己的显卡和bios适应的rom。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;bios的rom的地方，查找自己需要的，&lt;a href=&quot;https://www.techpowerup.com/vgabios/&quot;&gt;https://www.techpowerup.com/vgabios/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;刷rom的软件,&lt;a href=&quot;https://www.techpowerup.com/download/bios-flashing/&quot;&gt;https://www.techpowerup.com/download/bios-flashing/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;amd的有ui，nvidia nvflash没有ui，直接双击打开的是帮助文档。使用方式，在下载的那个文件，在路径栏输入cmd，点击ctrl进入命令提示符，&lt;code class=&quot;highlighter-rouge&quot;&gt;nvflash64 -b beifen.rom&lt;/code&gt;备份,&lt;code class=&quot;highlighter-rouge&quot;&gt;nvflash64 download.rom&lt;/code&gt;download是下载的rom文件，放同一个目录，运行一下，执行成功，重启。完成刷。&lt;/p&gt;</content><author><name>abearxiong</name></author><category term="显卡" /><category term="问题" /><summary type="html">在安装系统后，win10会自动带有驱动的，在查看设备管理器的时候，会看到GTX970的设备是显示感叹号的！点开查看显示是设备错误，错误码是43。第一次装的是1903系统。 使用过鲁大师安装驱动，安装完就黑屏。重启之后，桌面的分辨率是800*800，不能修改。用驱动精灵依旧是这样的问题。 重装了win10 1809，问题依旧，发现把GTX970的驱动禁用后，重启可以看到分辨率正确。 一直思考，如果显卡出了问题，为什么，作为一个独显，能够显示，而不是无信号或者黑屏，而只有在安装完驱动，禁用启用才会出现黑屏。 之后反复装系统，最后装了一次win7，打算测试win是否可行，但是依旧不行，于是用GPU-Z查看显卡，在官网下载的GPU-Z，查看Graphics Card显卡，发现关于Pixel Filrate,关于GPU Clock等等的一些不是为0就是不显示，查看Sensors的菜单，只显示四行，更多的应该有的比如显示器的状态PerfCap Reason等等很多都不显示。所以在大量重装的过程中，到底是显卡，驱动，还是主板出了问题呢？我一直在查询资料。 偶然查看到了一篇文章记一次显卡故障解决日志,我然后就尝试重装bios，这时，我已经把系统又安装为了win10 1903，win10系统不需要安装鲁大师等等，我发现只要有网络，那么win10可以在设备管理器哪里右键更新驱动程序，自动搜索更新的驱动程序软件进行下载和安装网上的驱动。 经过BIOS的重新安装，我解决了我两天的系统安装经过。 在这里描述一下，我是独显，能够显示，但是驱动安装不上，设备管理器显示设备错误43，分辨率不对，而且不能调整分辨率。作为独显，能够把驱动禁用，正确显示，而且用鲁大师可以跑，FPS为0-3，跑分1000，GPU-Z能识别，但是有一些数据不显示。这都是我当时的显卡不显示的一些情况。 我刷bios，刷的是同一个，和自己本身安装的是一样的rom，相当于是更新了一下，我用nvidia nvflash刷bios的，不能保存bios？？？？不能备份，我就直接刷了。 显卡BIOS重刷 找到是在那个网站techpowerup，无论是amd还是nvdia都是那个网站，下载的东西都在这个网站。刷显卡bios的软件和biso的rom文件。 位置1. downloads里面tewaking导航的BIOS flashing刷新bios软件的地方。位置2.首页最上面的导航栏DATABASES中vga bios collection中，查找自己的显卡和bios适应的rom。 bios的rom的地方，查找自己需要的，https://www.techpowerup.com/vgabios/ 刷rom的软件,https://www.techpowerup.com/download/bios-flashing/ amd的有ui，nvidia nvflash没有ui，直接双击打开的是帮助文档。使用方式，在下载的那个文件，在路径栏输入cmd，点击ctrl进入命令提示符，nvflash64 -b beifen.rom备份,nvflash64 download.romdownload是下载的rom文件，放同一个目录，运行一下，执行成功，重启。完成刷。</summary></entry><entry><title type="html">volatile是什么</title><link href="http://0.0.0.0:4000/java/2019/08/volatile%E6%98%AF%E4%BB%80%E4%B9%88.html" rel="alternate" type="text/html" title="volatile是什么" /><published>2019-08-14T09:39:07+08:00</published><updated>2019-08-14T09:39:07+08:00</updated><id>http://0.0.0.0:4000/java/2019/08/volatile%E6%98%AF%E4%BB%80%E4%B9%88</id><content type="html" xml:base="http://0.0.0.0:4000/java/2019/08/volatile%E6%98%AF%E4%BB%80%E4%B9%88.html">&lt;p&gt;关于内存的可见性，如果单纯的使用线程，会出现线程间的共享变量是不可见的，所以共享数据其中一个线程变了，但是显示是不能够的显示的。每一个线程都有独立的一个缓存进行提高效率，但是为了让线程中的共享数据的显示，需要有其他解决办法。&lt;/p&gt;

&lt;p&gt;如果加锁是可以解决问题的，但是会出现消耗，而对线程中的共享变量使用volatile的关键字会使得变量共享可见。&lt;/p&gt;

&lt;p&gt;volatile保证了不同的线程对这个变量进行操作时的可见性，即一个线程修改对其他线程来说是立即可见的。禁止进行指令重排序。&lt;/p&gt;

&lt;p&gt;volatile无法保证对变量操作的原子性，不具有互斥性。&lt;/p&gt;

&lt;p&gt;轻量级的内容原子性&lt;/p&gt;

&lt;h2 id=&quot;什么是内存的不可见性&quot;&gt;什么是内存的不可见性&lt;/h2&gt;

&lt;p&gt;当多个线程操作共享数据时，彼此不可见。&lt;/p&gt;

&lt;p&gt;同步锁是每次刷新缓存，效率低。多个线程访问的话，会出现多个线程判断，阻塞问题。&lt;/p&gt;

&lt;h2 id=&quot;cas算法保证原子性&quot;&gt;cas算法保证原子性&lt;/h2&gt;

&lt;p&gt;AtomicInteger s = new AtomicInteger();&lt;/p&gt;

&lt;p&gt;s.getAndIncrement();//或者其他&lt;/p&gt;</content><author><name>abearxiong</name></author><category term="多线程" /><category term="java" /><summary type="html">关于内存的可见性，如果单纯的使用线程，会出现线程间的共享变量是不可见的，所以共享数据其中一个线程变了，但是显示是不能够的显示的。每一个线程都有独立的一个缓存进行提高效率，但是为了让线程中的共享数据的显示，需要有其他解决办法。 如果加锁是可以解决问题的，但是会出现消耗，而对线程中的共享变量使用volatile的关键字会使得变量共享可见。 volatile保证了不同的线程对这个变量进行操作时的可见性，即一个线程修改对其他线程来说是立即可见的。禁止进行指令重排序。 volatile无法保证对变量操作的原子性，不具有互斥性。 轻量级的内容原子性 什么是内存的不可见性 当多个线程操作共享数据时，彼此不可见。 同步锁是每次刷新缓存，效率低。多个线程访问的话，会出现多个线程判断，阻塞问题。 cas算法保证原子性 AtomicInteger s = new AtomicInteger(); s.getAndIncrement();//或者其他</summary></entry><entry><title type="html">传说之旅1406 星期五 模块</title><link href="http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/08/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851406-%E6%98%9F%E6%9C%9F%E4%BA%94-%E6%A8%A1%E5%9D%97.html" rel="alternate" type="text/html" title="传说之旅1406 星期五 模块" /><published>2019-08-02T23:03:33+08:00</published><updated>2019-08-02T23:03:33+08:00</updated><id>http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/08/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851406-%E6%98%9F%E6%9C%9F%E4%BA%94-%E6%A8%A1%E5%9D%97</id><content type="html" xml:base="http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/08/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851406-%E6%98%9F%E6%9C%9F%E4%BA%94-%E6%A8%A1%E5%9D%97.html">&lt;p&gt;如何把小程序模块化和小程序使用方式和编程方式更快。&lt;/p&gt;</content><author><name>abearxiong</name></author><category term="传说之旅" /><summary type="html">如何把小程序模块化和小程序使用方式和编程方式更快。</summary></entry><entry><title type="html">传说之旅1405 星期四 实践能力</title><link href="http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/08/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851405-%E6%98%9F%E6%9C%9F%E5%9B%9B-%E5%AE%9E%E8%B7%B5%E8%83%BD%E5%8A%9B.html" rel="alternate" type="text/html" title="传说之旅1405 星期四 实践能力" /><published>2019-08-01T23:57:24+08:00</published><updated>2019-08-01T23:57:24+08:00</updated><id>http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/08/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851405-%E6%98%9F%E6%9C%9F%E5%9B%9B-%E5%AE%9E%E8%B7%B5%E8%83%BD%E5%8A%9B</id><content type="html" xml:base="http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/08/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851405-%E6%98%9F%E6%9C%9F%E5%9B%9B-%E5%AE%9E%E8%B7%B5%E8%83%BD%E5%8A%9B.html">&lt;p&gt;敲代码？？？？&lt;/p&gt;</content><author><name>abearxiong</name></author><category term="传说之旅" /><summary type="html">敲代码？？？？</summary></entry><entry><title type="html">传说之旅1404 星期三 旅</title><link href="http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/08/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851404-%E6%98%9F%E6%9C%9F%E4%B8%89-%E6%97%85.html" rel="alternate" type="text/html" title="传说之旅1404 星期三 旅" /><published>2019-08-01T23:57:07+08:00</published><updated>2019-08-01T23:57:07+08:00</updated><id>http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/08/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851404-%E6%98%9F%E6%9C%9F%E4%B8%89-%E6%97%85</id><content type="html" xml:base="http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/08/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851404-%E6%98%9F%E6%9C%9F%E4%B8%89-%E6%97%85.html"></content><author><name>abearxiong</name></author><category term="传说之旅" /><summary type="html"></summary></entry><entry><title type="html">小程序使用vant-weapp UI</title><link href="http://0.0.0.0:4000/%E5%89%8D%E7%AB%AF/2019/08/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8vant-weapp-UI.html" rel="alternate" type="text/html" title="小程序使用vant-weapp UI" /><published>2019-08-01T11:13:21+08:00</published><updated>2019-08-01T11:13:21+08:00</updated><id>http://0.0.0.0:4000/%E5%89%8D%E7%AB%AF/2019/08/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8vant-weapp-UI</id><content type="html" xml:base="http://0.0.0.0:4000/%E5%89%8D%E7%AB%AF/2019/08/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8vant-weapp-UI.html">&lt;p&gt;初始引入&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;miniprogram右键打开终端输入npm i vant-weapp -S –production 出现package-lock.json&lt;/li&gt;
  &lt;li&gt;之后输入npm init -y =》出现package.json&lt;/li&gt;
  &lt;li&gt;查看package.json详情，本地设置，“使用npm模块”勾选&lt;/li&gt;
  &lt;li&gt;在“工具”，选择”构建npm“&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;出现miniprogram_npm&lt;/p&gt;

&lt;p&gt;使用方式，在页面json中使用引入&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;usingComponents&quot;:{
        &quot;van-button&quot;: &quot;vant-weapp/button&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在xml引入模块&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;van-button type=&quot;primary&quot;&amp;gt;按钮&amp;lt;van-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>abearxiong</name></author><category term="微信小程序" /><summary type="html">初始引入 miniprogram右键打开终端输入npm i vant-weapp -S –production 出现package-lock.json 之后输入npm init -y =》出现package.json 查看package.json详情，本地设置，“使用npm模块”勾选 在“工具”，选择”构建npm“ 出现miniprogram_npm 使用方式，在页面json中使用引入 { &quot;usingComponents&quot;:{ &quot;van-button&quot;: &quot;vant-weapp/button&quot; } } 在xml引入模块 &amp;lt;van-button type=&quot;primary&quot;&amp;gt;按钮&amp;lt;van-button&amp;gt;</summary></entry><entry><title type="html">传说之旅1403 星期二 技术博客要有技术博客的样子</title><link href="http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/07/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851403-%E6%98%9F%E6%9C%9F%E4%BA%8C-%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E8%A6%81%E6%9C%89%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%A0%B7%E5%AD%90.html" rel="alternate" type="text/html" title="传说之旅1403 星期二 技术博客要有技术博客的样子" /><published>2019-07-30T23:56:20+08:00</published><updated>2019-07-30T23:56:20+08:00</updated><id>http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/07/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851403-%E6%98%9F%E6%9C%9F%E4%BA%8C-%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E8%A6%81%E6%9C%89%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%A0%B7%E5%AD%90</id><content type="html" xml:base="http://0.0.0.0:4000/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%85/2019/07/%E4%BC%A0%E8%AF%B4%E4%B9%8B%E6%97%851403-%E6%98%9F%E6%9C%9F%E4%BA%8C-%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E8%A6%81%E6%9C%89%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%A0%B7%E5%AD%90.html">&lt;p&gt;在8月这段时间，我在学习一些其他的东西，cheatEngine和lol，因为cheatEngine是关于汇编的知识，所以我去学习和了解了一大部分关于汇编的知识，小甲鱼汇编，cheatEngine使用方式，空闲时间就自己闲逛。&lt;/p&gt;

&lt;p&gt;9月16日记录：&lt;/p&gt;

&lt;p&gt;冷静完成了，在之前自己只有笔记本电脑，自己敲代码的方式就是笔记本，而我的笔记本无论是运行速度，还是打开软件的速度都是很慢的，所以我就需要花费更多的时间去实现我想要的功能。&lt;/p&gt;

&lt;p&gt;我在9月2日附件的时候买的一个新的二手电脑电脑，实现了敲代码更快的方法，使得我的编程过程更加的快捷。所以我把之前的笔记本把运行很慢的一些程序进行删除，在台式电脑上安装，这样很舒适，而二者之间的同步方式使用onedrive，在9月10附近，我在v2ex查看到一个家庭版的office365合用，实现了我的onenote的同步和onedrive的1T的同步，感觉很舒服。&lt;/p&gt;

&lt;p&gt;在这个拿到二手台式的时间范围内，我除了安装双系统，安装软件之外，自己去做关于小程序的编程和关于快捷键的编程。为了实现更方便的的生活，我打算加大力度完善我需要的关于快捷键的功能。&lt;/p&gt;</content><author><name>abearxiong</name></author><category term="传说之旅" /><summary type="html">在8月这段时间，我在学习一些其他的东西，cheatEngine和lol，因为cheatEngine是关于汇编的知识，所以我去学习和了解了一大部分关于汇编的知识，小甲鱼汇编，cheatEngine使用方式，空闲时间就自己闲逛。 9月16日记录： 冷静完成了，在之前自己只有笔记本电脑，自己敲代码的方式就是笔记本，而我的笔记本无论是运行速度，还是打开软件的速度都是很慢的，所以我就需要花费更多的时间去实现我想要的功能。 我在9月2日附件的时候买的一个新的二手电脑电脑，实现了敲代码更快的方法，使得我的编程过程更加的快捷。所以我把之前的笔记本把运行很慢的一些程序进行删除，在台式电脑上安装，这样很舒适，而二者之间的同步方式使用onedrive，在9月10附近，我在v2ex查看到一个家庭版的office365合用，实现了我的onenote的同步和onedrive的1T的同步，感觉很舒服。 在这个拿到二手台式的时间范围内，我除了安装双系统，安装软件之外，自己去做关于小程序的编程和关于快捷键的编程。为了实现更方便的的生活，我打算加大力度完善我需要的关于快捷键的功能。</summary></entry></feed>